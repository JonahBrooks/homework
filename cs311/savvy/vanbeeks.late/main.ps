%!PS-Adobe-2.0
%%Creator: dvips(k) 5.96.1 Copyright 2007 Radical Eye Software
%%Title: main.dvi
%%CreationDate: Fri Mar  2 13:30:55 2012
%%Pages: 2
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%DocumentFonts: CMR10 Helvetica helvetica
%%DocumentPaperSizes: Letter
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -R -Poutline -t letter main.dvi -o main.ps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2012.03.02:1330
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
%!
% PostScript prologue for pstricks.tex.
% Version 1.01, 2006/01/11
% For distribution, see pstricks.tex.
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, epects 2 parameter
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%----------------- hv added 20050516 ---------------
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
/RadtoDeg { 180 mul Pi div } bind def % convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def % viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
/PathLength { flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
  }{ /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
grestore } def
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
  ifelse { pop } repeat a } def
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/OpenBezier { BezierNArray n 1 eq { pop pop } { ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB curveto }
ifelse } def
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % add/sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul x add
  a2 sin ry mul y add
  a1 cos rx mul x add
  a1 sin ry mul y add
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
%!
%% PostScript prologue for pstricks.tex.
%% Version 2.00,                                    Suggestion of 2006/12/19
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Herbert Voss (hv) - 2004/12/27 
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%
10 dict dup begin
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def
%                See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch/.notdef put} for
  Encoding
    dup (b) 0 get /Bullet put
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
  CharProcs begin
    /CirclePath {0 0 500 0 360 arc closepath} def
      /Bullet {CirclePath fill} def
	  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
	  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
    /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto
		closepath} def
	  /SolidTriangle {TrianglePath fill} def
      /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
      /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
    /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto
		closepath} def
      /SolidSquare {SquarePath fill} def
      /Square {SquarePath .89 .89 scale SquarePath eofill} def
      /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
    /PentagonPath {-337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
		0 574.7 lineto -546.6 177.6 lineto closepath} def
      /SolidPentagon {PentagonPath fill} def
      /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
      /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
    /HexagonPath {0 550 moveto -476 275 lineto -476 -275 lineto
		0 -550 lineto 476 -275 lineto 476 275 lineto closepath} def
      /SolidHexagon {HexagonPath fill} def
      /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
      /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
	/AsteriskPath {20 0 moveto 10 250 180 500 0 500 curveto
		-180 500 -10 250 -20 0 curveto closepath} def
      /Asterisk {AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
	    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath 
		fill} def
	/Basterp {50 250 220 500 0 500 curveto
        -220 500 -50 250 -50 30 cos 100 mul curveto} def
	/BoldAsteriskPath {50 30 cos 100 mul moveto  Basterp
                     60 rotate Basterp 60 rotate Basterp
                     60 rotate Basterp 60 rotate Basterp
                     60 rotate Basterp closepath} def
      /BoldAsterisk {BoldAsteriskPath fill} def
	  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
    /CrossPath {40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
        -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
		40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath} def
    /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
        -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
		80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath} def
      /Add {CrossPath fill} def
      /Mul {45 rotate CrossPath fill} def
      /BoldAdd {BoldCrossPath fill} def
      /BoldMul {45 rotate BoldCrossPath fill} def
	  /Oplus {CirclePath .9 .9 scale CirclePath eofill
		.775 .775 scale CrossPath  fill} def 
	  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
	  /BOplus {CirclePath .8 .8 scale CirclePath eofill
		.775 .775 scale BoldCrossPath fill} def 
	  /Otimes {CirclePath .9 .9 scale CirclePath eofill
		45 rotate .775 .775 scale CrossPath fill} def 
	  /BOtimes {CirclePath .8 .8 scale CirclePath eofill
		45 rotate .775 .775 scale BoldCrossPath  fill } def 
	  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
    /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto
		closepath} def
      /Bar {BarPath fill} def
    /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto
		closepath} def
      /BoldBar {BoldBarPath fill} def
    /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 
		428.5 0 lineto closepath} def
      /SolidDiamond {DiamondPath fill} def
      /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
      /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
    /.notdef { } def
  end
  /BuildGlyph {
    exch
    begin
%      Metrics 1 index get exec 0
       0 0
%      BBoxes 3 index get exec
      -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
      setcachedevice
      CharProcs begin load exec end
    end
  } def
  /BuildChar {
    1 index /Encoding get exch get
    1 index /BuildGlyph get exec
  } bind def
end
/PSTricksDotFont exch definefont pop


%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
%!
% PostScript prologue for pst-node.tex.
% Version 97 patch 1, 97/05/09.
% For distribution, see pstricks.tex.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin /T /translate load def end
/NewNode { gsave /next ED dict dup 3 1 roll def exch { dup 3 1 roll def }
if begin tx@Dict begin STV CP T exec end /NodeMtrx CM def next end
grestore } def
/InitPnode { /Y ED /X ED /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
/InitCnode { /r ED /Y ED /X ED /NodePos { NodeSep r add dup Cos mul exch
Sin mul } def } def
/GetRnodePos { Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def
} ifelse Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def }
ifelse dx Sin mul abs dy Cos mul abs gt { dy Cos mul Sin div dy } { dx
dup Sin mul Cos Div } ifelse } def
/InitRnode { /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub
/u ED /NodePos { GetRnodePos } def } def
/DiaNodePos { w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
Cos mul exch Sin mul } def
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
{ 0 Dist Sin mul } ifelse } ifelse Do } def
/GetEdge { dup 0 eq { pop begin 1 0 NodeMtrx dtransform CM idtransform
exch atan sub dup sin /Sin ED cos /Cos ED /NodeSep ED NodePos NodeMtrx
dtransform CM idtransform end } { 1 eq {{exch}} {{}} ifelse /Do ED pop
XYPos } ifelse } def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA { NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA
AddOffset yA add /yA1 ED xA add /xA1 ED } def
/GetEdgeB { NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB
AddOffset yB add /yB1 ED xB add /xB1 ED } def
/GetArmA { ArmTypeA 0 eq { /xA2 ArmA AngleA cos mul xA1 add def /yA2 ArmA
AngleA sin mul yA1 add def } { ArmTypeA 1 eq {{exch}} {{}} ifelse /Do ED
ArmA AngleA XYPos OffsetA AngleA AddOffset yA add /yA2 ED xA add /xA2 ED
} ifelse } def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { /b ED /a ED /NodeSepTypeB ED /NodeSepTypeA ED /NodeSepB ED
/NodeSepA ED /OffsetB ED /OffsetA ED tx@NodeDict a known tx@NodeDict b
known and dup { /NodeA a load def /NodeB b load def NodeA GetCenter /yA
ED /xA ED NodeB GetCenter /yB ED /xB ED } if } def
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
/NCAngles { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform pop xB2 yB2 mtrx transform exch pop mtrx
itransform /y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA2
yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end /LPutVar [ xB1
yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def /LPutPos { LPutLines } def
/HPutPos { HPutLines } def /VPutPos { VPutLines } def } def
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate def
xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0 mtrx
transform 3 -1 roll 0 gt { /yB2 exch yB2 add def /xB2 exch xB2 add def }
{ /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse mark ArmB
0 ne { xB1 yB1 } if xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict
begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx
def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCDiag { GetEdgeA GetEdgeB GetArmA GetArmB mark ArmB 0 ne { xB1 yB1 } if
xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false Line end
/LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCDiagg { GetEdgeA GetArmA yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
GetEdgeB mark xB1 yB1 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin
false Line end /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def
/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /DvipsToPDF { 72.27 mul Resolution div } def /PDFToDvips { 72.27 div
Resolution mul } def /HyperBorder { 1 PDFToDvips } def /H.V {pdf@hoff
pdf@voff null} def /H.B {/Rect[pdf@llx pdf@lly pdf@urx pdf@ury]} def
/H.S { currentpoint HyperBorder add /pdf@lly exch def dup DvipsToPDF
/pdf@hoff exch def HyperBorder sub /pdf@llx exch def } def /H.L { 2
sub dup /HyperBasePt exch def PDFToDvips /HyperBaseDvips exch def currentpoint
HyperBaseDvips sub /pdf@ury exch def /pdf@urx exch def } def /H.A {
H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF HyperBasePt
sub sub /pdf@voff exch def } def /H.R { currentpoint HyperBorder sub
/pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint exch
pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def } def systemdict
/pdfmark known { userdict /?pdfmark systemdict /exec get put }{ userdict
/?pdfmark systemdict /pop get put userdict /pdfmark systemdict /cleartomark
get put } ifelse
 
@fedspecial end
%%BeginFont: CMR10
%!PS-AdobeFont-1.1: CMR10 1.00B
%%CreationDate: 1992 Feb 19 19:54:52
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.00B) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMR10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMR10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 12 /fi put
dup 39 /quoteright put
dup 40 /parenleft put
dup 41 /parenright put
dup 44 /comma put
dup 45 /hyphen put
dup 46 /period put
dup 47 /slash put
dup 48 /zero put
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 53 /five put
dup 55 /seven put
dup 56 /eight put
dup 57 /nine put
dup 58 /colon put
dup 65 /A put
dup 66 /B put
dup 67 /C put
dup 68 /D put
dup 70 /F put
dup 72 /H put
dup 73 /I put
dup 74 /J put
dup 77 /M put
dup 78 /N put
dup 83 /S put
dup 84 /T put
dup 86 /V put
dup 87 /W put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 106 /j put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 113 /q put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 118 /v put
dup 119 /w put
dup 120 /x put
dup 121 /y put
readonly def
/FontBBox{-251 -250 1009 969}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF7158F1163BC1F3352E22A1452E73FECA8A4
87100FB1FFC4C8AF409B2067537220E605DA0852CA49839E1386AF9D7A1A455F
D1F017CE45884D76EF2CB9BC5821FD25365DDEA6E45F332B5F68A44AD8A530F0
92A36FAC8D27F9087AFEEA2096F839A2BC4B937F24E080EF7C0F9374A18D565C
295A05210DB96A23175AC59A9BD0147A310EF49C551A417E0A22703F94FF7B75
409A5D417DA6730A69E310FA6A4229FC7E4F620B0FC4C63C50E99E179EB51E4C
4BC45217722F1E8E40F1E1428E792EAFE05C5A50D38C52114DFCD24D54027CBF
2512DD116F0463DE4052A7AD53B641A27E81E481947884CE35661B49153FA19E
0A2A860C7B61558671303DE6AE06A80E4E450E17067676E6BBB42A9A24ACBC3E
B0CA7B7A3BFEA84FED39CCFB6D545BB2BCC49E5E16976407AB9D94556CD4F008
24EF579B6800B6DC3AAF840B3FC6822872368E3B4274DD06CA36AF8F6346C11B
43C772CC242F3B212C4BD7018D71A1A74C9A94ED0093A5FB6557F4E0751047AF
D72098ECA301B8AE68110F983796E581F106144951DF5B750432A230FDA3B575
5A38B5E7972AABC12306A01A99FCF8189D71B8DBF49550BAEA9CF1B97CBFC7CC
96498ECC938B1A1710B670657DE923A659DB8757147B140A48067328E7E3F9C3
7D1888B284904301450CE0BC15EEEA00E48CCD6388F3FC3BEFD8D9C400015B65
0F2F536D035626B1FF0A69D732C7A1836D635C30C06BED4327737029E5BA5830
B9E88A4024C3326AD2F34F47B54739B48825AD6699F7D117EA4C4AEC4440BF6D
AA0099DEFD326235965C63647921828BF269ECC87A2B1C8CAD6C78B6E561B007
97BE2BC7CA32B4534075F6491BE959D1F635463E71679E527F4F456F774B2AF8
FEF3D8C63B2F8B99FE0F73BA44B3CF15A613471EA3C7A1CD783D3EB41F4ACEE5
20759B6A4C4466E2D80EF7C7866BAD06E2A1040FAF2DE1FD6AFD5FD97EAAB614
956897A7BC784E9865B00EE8B49B918E886049F1F4939403EADAB83A4D8C332E
2221AF8F6F4A4954501CB6A6268AC96F7091245F034BD65542DF47BC7BBAD667
1EE6AF9187E298CB7AABA58E3FB5B4C7E86616C1A830A4A937C265CC28A83EED
8F3C971D6DF5A50A615B713F5332E0CF05C754FD76916FECE4DB2807334C34E1
E2418FFF1B4429A564AB857F1E23337C75E729645AEBE7F8967630A40E00F8C1
3054F2BE2768682E50D0B43E3CE3897D9EE7257E77F9894CD4395C21585D16F8
AEFE05217ED4F78C31FD635A00CE5D0DFC7B0A6BF9444B62C836087731D6D205
24A45B3C8D80983A67377EBBEE171DE0B4A21368F9B83AF7CB286D8389785E93
B11277C65D4D789AF99B1D7A3032947A51DFABA0DA3B94DFA8ECE2B7374827AE
168634FA007F8981ADA04F102ED9C2D115C27E27E6DC010FF6732239F392A8FF
CBCCE8A3EDE547451191D88E3360E7817552B352D6EC72053EB037E1B3456A78
39CBFD2D0B6AEA91BC7594958ED0FBF7B652D4C20EC662F2726365F8774F02A5
CFE926BD4891985D68CFD7AD774A340A57DCAB2B635F85832FA320CD9FE204CF
2F99B5E9376A65F2F8A60ED33B412E53E7106DF6948E0619D9A0EB2DDD3ED1A0
CAEA0DBDB8E20C47C783285A553C019F9BF0E9B31093AF70DB81A133E6B4D9FA
38C2D1A29D088F6F06857BBA752FD2A7D6BC309B35C820F240E2EF7161259D32
CE7477069EC7E529672FEB056B1CCB5397E4EB52EC153DCD5A2299128BEF7810
BA1B994890898BA2A85D2C7E4106BF0FE444D1132EB0C10F404ECDC80D3AAE74
D94786463832323BD471679567CA24EFE8CAA19BC45C5BA02B23E987D2EF0485
47A28E378A658CE0F297793FDA280740AD8B602B55A6E2337395073DA35E01AB
323AB5C0C5E273FF57666C893C4A28F44892D6D548E3AEE8B05953E5349386E4
02751580E016DE147336FBF39AB756CE03D3FAFFB681C944F40BE677E3DD5227
9FCECD3C4B2615E55919FB96606342629C1155E64774F09A41B28C8C18C3AE71
81018FF1A73B7C1F174EB9C92119DC9B35AFF150778C44E25FCF08C8FCCBB1CC
6422C8A8BE23790F3F81D69BD4A3A07C273ABD8D91DE0FBE54BFB091875412D1
84AFF9AF70D965F771FFB7FA0FFF14BF4970D229E4C7F584D303709EDEA88C96
7AB9D9EADF805D65B528073CE57D05172451957851CDC54DCF247250C134FF33
B6B0FDE65F69C3022139ED970AA1C4B69D52FEEB230FBE7386FA6EC17ECEDC2B
5C815A19621A9BC5B1D2354D5C6E35825CFC580565C0E1A61E607F91871D6AEF
5C04610D6246BF0D1C5FF034CEA604CDFE813183C5A277DB7AC8AC5568899A2A
8BF9523FD2953F6A28B1DE32995AF792FA4ECB9EE271CFC0C44E8D514601025F
4B7B241294C6CFE68A5B61F3244B422D0CB191ADBD1EFF555D1B5E02815E36FB
7854812E5EEF2DEAAA5B6E55E4A063D362FCF942FB1478F87F53BBB711FE83B1
C0E46104D60BAFBE98AF0215E8943ECEB143885100896C9F76258F9DB0F5B753
57FF4AC002CBD86C98BE614D4B95ED7F0D94946DF02F0910B9975C7BFFD928EA
B6C65CAD609C33FF229220586C525525686823568FF0701373AECA6817DC718C
C695E157006C6BFBD6011E303C9489C5BA7079B5B0E8A0AFF506FF4F5E6107EF
CA0202FF247470FA97FA7A655F57DCEE5EC82B467F5903B7DFEDE715402137F6
EA89470F329EFB3C3C36CA403D8090D1F7C65D922FA713B7006035F87829B7AF
E3332E7D11E55D27DDCBC83EB0F0E0AF3069FA79510DBE47D60199D48AAC46FD
93E6830FF9F0378B9ACFE3BE3836634E07ABD758E8F18263F72AC8A015277936
8295CF924A4917D06535787EE29E3B9C36B15CB3207AFAFE07E0B43DE2557A0E
F6AD2590F68FE92242EB6426B5B5E002A4050A56F185A6F42049418AED9AD1AB
84F72BA65EB06D5925C97393C3190D9C7BF694069646AC91E507F170387D6169
DF9EA55D13EFE6B523AD34FAF298FEA0A76FB5E7EE358B37D3CD61B5CFBD32BD
FA678CEE378952C85452E5976A5B629A5834A53752B2B5C3B3F2A864C5C64170
FC6C2B6A91D3C4F06754D845114B5EEE62E09C019240B1644C59A2E7E93BD06D
B34DEBEC8783A0DF0CE6FCFF75F225E872B9BF62B99037B9564A9CF7831054FD
67BC190A9B2B74D6808D0D0ECAAF60CE0D7A38DB57990BF753A44B5CC7219584
EE180E39BF6B699AA80DD11285EEB9AD25220944E7C9324EC8A5FAF60E3FA090
045C0936F16B142E1C371EDFA2FAAE8CF8253FB4825714EFDFE24A84E4B40D4C
70D264A35C202DA76802E160EEE576FF7252BB92BC9398FDB3AB5C18463C80A0
3A22AA163778B38A3B2D02E37A768414F82A3909721E51D66635220FDD427C16
66525341B52A959C9B866D5EC6A8CCE506C8CCA720C02AB43C97C573F26BEEAA
50824F90664144FE59CB9DADC3460FE0F4BF347B4AFDC73C39980453300336FE
5BE247C0945CB016BD150EF8E87B23135247F9F15625B094EC771DD1720380D0
53E0783803064084A54D0D8991B7870F959001EA88BEE07429FDB1A8BBCE27D4
5AAF563DD01CC13CBF30EAFB7D05C1624923C10251E7E4B8A4FB5E13D418C659
1DAC352D9FD9AAC956E73E817E7F04377C091B4C433D0E965805E44ADCCAB464
0998A261DAE252E69F2990EFF9DE3500B42A42A7B19C2C7E35DDC99AC0A61AD0
3E0546EA9E78A8FEAD106AC78882AC9BB3F1851D87C2A8692671E8BF82F08036
CDC4B4903FA11EC68091A099138FF861F3027128E211895ADE44C5C5C73D2F55
9783C55FBB37E94C46CE3DA11A66EEBD9C8F2003DFBC5E31E4B19AF79BFBCB89
F9EC628DF05DEDE5E48BA34312EA6D7CB0A974C705972CB62490F4916080AA56
D5CA54BD3535AD3432AC29E91BDFEC0A2D45DF776EAD6B08E222AF69BE54FE4B
852D4389365A70A2CF44072ABB50023893BD134B343DD1212158EFBF5DA157EF
63CD52717AE844C93F178471A5C481A534826695C2001EDDCE50A52BFFB92801
C785800B2C6CFC043540858A78594E8024CB3B8CBF7053A36164685C777862C1
D5AECAE027E6157D789318439AFEF10BF86A7CF4EEA41F559FD8BB70CE2248A0
E5A6FF622795E23C131499FCA09771A7A557648DEE292D092FB55A9A75E2521C
D0B7FA64CE12B7A052B6BC47F6387E336E04CC863A58D264BB62662EC4F8A0FB
8716560628B827B5C6AD5610624E8C53F1F18E87611E58F893B28F658A6FD6C2
73AD06397194C6735F65EE40578618CECA27D50821B70FF3ABAED63D9F12BDB4
4BD78ED123D5080B3CEB2C4439EA52A71AEA3A920E16F0A5D490821D8EC10270
1E5D34DEEF7FB66315FC4A467421B66D2CFF5227ECFC75DF163050D7965F5B6B
848A507835848F9DEBA1123650CC987FAD35E752DA84DBE6C3CDAB2A17B7FABC
F45DBAAC406A8ACC66686D483AED027202773C71334C0A194FE8782D79E9820C
E0672BA7CB6C8EF5C5E84A9FC790490922EB7619B6481488333D156DC84F9EA8
2AFF664CF2FE61DABA84BDEED466A1D3C5FCFFC5BC1FABB1BBC762B4576FA78A
949FD84FC64138581F4FA253061CE8619E0C04A6D4E1C324882DF448C319136C
084FB09DA1351B92FBA89D95505767152BFEB44FB211DFA58F242C2C442DA544
521426566D82DD5C44953104BE8F78BC7902D278A0E1B1660C2CB407CFF5A48F
99A50E04410E4842A79CA7E80D758DBB791B0ED02D26F14273B32471531403C3
8DEEA39A2D65731AE704A1F74AF62140AA681AD8D22AE225AFB7A4A46A307652
E36D98D87F4B496192FF66FF9B05F4694166EA2F22ED694CF855382B099F1480
7515FE9F3099E5913A927235BC2D500049EFA27ED71B6FA9287CC8800559EB45
AF6F379749CEFE29E8CE2FDC45FDB9402A618698CECEFB38866B5CA0348D184E
B10D234274E64A64996FAF1F7233CB3B14B2E32DF10DCF9B83F1226175DB6AC8
C47EC3AE3170DE41E0D7CDA57A8C3C31FBFAD67E60D60541C8CEA3999B83AA94
9471F19CE33BF13E827B8FC80A5349954538AB0B864A89747268D8A6A1BA8F91
5F1A7BA470E1A87BD62D1AF2F8ED7AF9C641C084E04EAED1A5F96AB02FB81F23
5DB03378AF0C1E44E5B6D5765E5EE4EB7FE6B355EF205AED77638202330D5564
33394911B08E07C528B7C97C749628502C8BF332EE777518251D3BA874D07F96
1AC0463301961B24E599C5943D445052EB164C26730B32B606EA7DD506505019
D301CCACF2BE08F4988E83F89BB9E028AB5B37FFBC0C42630B5FE77143ABA1E1
552BF067B1B341D21483CA0DC96F29048D2AE2EED2904DFEC52EA918851E6D7F
5211FC17FF79217F3F7947B9649F06A5E0E1DBD079DC573F0F0D16F94111001E
464103E818C111CB374BB00B9FCAC5ED44649E117CDD31CCFF9E9E59092B6F34
05CB365681CC63179B824D2F76B2777BD2529EE691790835DA2A9FD3A1D37936
1EAA71E5D65D2B57415F39A978162252D4D146BC7791F0C0926E7C450FD941F6
1D837AFA07250A7018579EDDF79307851261AF11F1C9CCC07D3071DC7A65F791
7B8EB6EBB582EF355E088DEAA0377F914BF1A6724A807B3C045445A001248710
E317326A33761E7888C38B8DD42FFEB433AF5450E8E0B3481B99E1C5149321B3
09533B6691D9F741A4F539FEFB07D8D1A3768572FDEC0EF54BD8B188915524EB
C9B1B714362E3D99E91A2ADF224BAB3F71D3A88AA2581E40C41A6F88F638FB0B
712BE36A1E203B38FD688A6156B7CEFF2C413F68832D1A405581D3127888E97E
B33B1B2E226FBB767C2770231611583B767046547D83F60F273CC6A21BFDEECA
63104100E9437AB6FC2B3C0E7362CFA227B485450A7C9FA378EE358EF73244BA
9AF1CD14922E9EE6A383E752BE460F4C90CC835DFF25ED9993CEE75A309DC62C
18719371BC4E658621B08432BCAA02501B50C431742E862B9A98F7CBF271AD6D
D9A84527840BC8FA53668ECCCF8EA8D3056ACA3FAD8D0DF65DE6B43316DA16CC
6506E4D96F35F9BDF3F818B130FF1A30BEB6563F82374DD7EF915DEC756A6EB8
F1A2EBF01CCC4B208B4255C40300D39BE59BC2F9DAFC8C84BCBBCCE7E4FC09FE
270905EABF1ED62787CA25A36EEA478DAD253C19BC26B6A518529324639B9C9A
DA5570540911CF579D7B9D9F336F707082753CF0440803F2DE7049710AF7A456
6BC8705C9C5C5A95F1056A4190090D8F39751839D4AF88F71B514DACE64B4321
C166FEDEE37B892A301E6A834378EE3CF1A0AFECD79AEE9C6A3DAAD36D1F419F
0BF48F5AE192233BA109C9D42D1A4BE8A57086F88EBEE5781318805536811E66
B7B5E9A6620339E94FD8483363C1ACA1EEC3AE5B7FB88E22BC9553DE888AA111
4A546CA6284F49399A5B01CF5076A6A450CEB1B576D9B130A747532A86930235
76948F3A31CE76EB09CBD793E74A3E9A650048BF321EB7A8B3230D299344F4D8
6976C5E1ADB7A113190CCD1A51BEF9D0FAEAF925C9F89685A62E10F2932C0BD5
41D2639958AABA45C9F4B38DEB3A22358121FC8AF5816DB14397783C72FF732D
170026DB11D63B6B20DA2F03BA803AA7AAC3360BF2CEC9E335E006D75551850A
6532E0FD1967091AF8FBAA451BC9BBF41AC8BD5CCD369BEF9D201852B5BFFE72
36153329297844AA6061CF23DF2A5A68ED7641B366E3DA8F15E3DA04D79A2DCC
A0B6F36A317BFA1AAC70F1C8D39A2C52B396AAEA952C199C17D32356BAA0BF51
385E1C6976C20D2631BC4C31E06F6B7E64129566BA38883BF9C82696C30413DF
228B9B6341604EDB7FBB2720D715B6D491903A982C5C6E6611FCAE531F80F2C3
3CE0A4321CE3C5995D819193124AD7F4B956DBB99E49E79BE5EB4DF17B6FD7F2
AA3FC44DE827D9112286FC9CD53DF82EAB2876D9DCC7FFFCB79DE6DA2FF3EC34
490D1D72523200527ADAA609B3D257758F810B59367C966E948D32AE91DD80F0
0B9C363826432595F435F2310D200799B9CF467D1C0B5F3D1825730B8E1C0973
D98D577F77D2AD0AF4F2E8AF2D4FA800175CCB45869E3955AFB9F610B6E94D3B
9BE9D79022BE7740DCD5C524892A82135FC82E81725A20DEDB0CDE0AA3D7C39F
F09AC565AE5C01C14B4B2357318A1D9AEB06214C6C3CA9AFD19EA11C0C2800EC
A6D35842B4343F96FCC25D23D77EA4821149681844137EB9CA47D374B152222D
A607202F245C7954E5BB14F0C855545E2FDCBD5DD514E16709F42881CA58095C
7E7B08294AEFA987C76427AC1613E8D2E3D5E1123993791B990FAA36D86677FD
6291B31FD6BD53F9C32A23100044A34AD0A639EDA276DDAA00CA7B962BAC0C85
8692E36023DBFF55EB30C6F0872C46F34CAEF1A389959CC0B3B02411477FDC34
7B8A0F1B64603EC4D0C99CA3EB4EAEBC0A091F40845AD5A09E4B42243046C95A
5316AA569EAAC14574BEE028EBA544DC08719FCE3116FEFC20CFE4925FAC24D2
1D7098598B2BE517AE3DA829B3AE8B54B7F96C145D63DD7848562B41C9802631
899BCF7EF6B862120B143DC54551D3682FD6ADFDA13AAA4820CCD802AA8470D2
4DF90A536440A33D4F2D12654487BBB60BB25A767CB43AE591825775B4D26447
20C4805FC2D801EA5B3645FA93A719CC7DB8F56DF2D55D8F948D99E68116C099
CBDA3D16AD2B3863521AA3C0B1FADFF0BA8032920358F6944CD05518032D058D
D7B56959367207E2B56FA1E9B5204661E9EBEE58BA2B1EDB2B861CEA260693C1
17ECF5E94D1CFA85E22B2284A018174D202101BCAAF7B514EF448E45CBD75003
F901B3521F4DFE862272B6F12F675966DCE172C66C0D9B48C6BE6265FF56EDD7
878BE73914C47A34A1E96D314C979BB080DE6512ECE341C508F57FCFF3EFF641
1526EA16C32F32CF00A7B9E027BB832A8C49C66E821CB8520799142F97DB01EE
D76B83614F565CF3F849ACCEF6E31467E7418ECE8DF151B8750FC3EA16428B8B
8810964F9BDD07BCE46724597EEBAF64EB7567EBCC1F61E1864BBD5080362465
A297F5B6F31ECDD8F9D94A410E91C3E02FDA2681C7E1784F134A8B8F6C30F07D
4974E9AD97DBAADA61DEEDF098CED2CE6DCA0D719D5878849FD0183E5DABA19A
04F74625118CB32D15E37A09F054D69A887E46F8C11D93C3753ED02F8DE1F306
AE72CB61E6CC9085C194083399EDEEBDC3D9D4120F4AFF1D0D2C5B9378F6F3C9
408EBB0D783D56C8CB7EB0AF878BDE92BAFEA6AEFD90C468F59AF54CA2C447F1
6A4D037A748A36AA38E4C2D73C8576963FFA3A12FDB2DE8719B54EEC24A9B6A9
EF36300F5C982620DCB991EA8FAB1272BF19D6C520877F9E92189887712CB881
6F8A188E6173D69C19A4EAF0640A12CDB4873E79149959CD825822E43069CAF0
2C0984D677307E8897651A4CAA603794FAD35654353C1E8846ECE92CE8321B3B
A0A9FC7F8916C0360AB1834B9580C94E822BC5425E5B080E36A70D4B47E8A6A1
91DC49FB474CCB37EEFAF40C0F9CA4B4F62C58300DEDCFF5268B04A5F52CB286
21F18147282D92E8E03A98197A1DAFC99B58D4AE239ED9459CE35233D4EA15A0
57C47552593AB2004FFA50C5E5C92CFC1DD42A7DABDB500F941107E266615689
5D17C0A6ABBA49E55B9FAEE0392995B0EE31942269BB2003EC0E4EA46B07F2D2
17D7999D955B69C6E7D65EDC86AB625198E11EC07C6806D8D61082D0DB9912E1
555B1746EFBB5481800EB8A0612BE3216CF770995D314626D898A3C90522F8E1
7FC5CAA4C19B7C91D7E72AEFEE8105B3F611883E7F0E08C7F38D217131F8512E
B45750C872F5E88E257B183B4EC55739B55F4246AD5B09EAE00C7CCF90386147
46B02B24AD81DB630DCC0687B35038A958E9993CB41F99D57C100F9213E4CB4F
C6025B6815803798CC1990A579F7C7DBA1ABD93260944810EB763DDE06CE6B0D
2FA18849E6C8B5C6A5B4E0C454C8E52BDDD139A14A78BDCBFD5559B0FB09AEB0
5B2F64A1BBBB9023AA2FF0BB6C004A0AF5B1551FFBBEA34935648BD6679725C8
89CC423AEF4670D8C1E91F7BC83F0D98AE97D3D086B229AF32B4B19C6997C6C1
65A9D783872192923F8B90F27D7401C96438D44B83EE333E0D5897C8CDD2E45B
F8935BA3AA83A77D4F969A6D13F0ADEC22C29C15CE43A6D7A3AEDF7B3D71AE7E
469792F9D930AB4F9243C006607E6A5AA794770944D0A6396FECC843B68685C0
890258B6768CF115FCDB42CF454E2B6559C43F761E95B148A3005DC0455E955E
ADB0EC82E136AC8DE2E361078A9CB34C7B09F128032C9825317CC22AAAE9C913
37C4545D73FEC2357D48F790B923DA030BE6A657FA758A5E2A43668B72BE2A70
54651D9ADE45227C8F4D8F5E440973BEEB2A4F3C56E5AF4BA17929BEB891816F
DD3DD5470A87CBD45C322EDF81F1444C1FCC6D6DE19F0C57F32403019801F51F
3FCC038B86400D58F0D097D5D6009FF62E58814EA383887BA530CD4E9C4D72FF
757638F0ECE10164494B5AC5B9AD2D98BB618255664D2306BF365A7973E79606
CC3D562BCFC107661CCF8BEFFB8620C62CC262375E733BBA5A969E0E6ED90F6E
B72A679B453A3612E6FBABEA892025ED7240A6C9B2A7E2ABF81E225A05BEE7A0
D520E92C5AD36C205C34194A99183423FCD1184C4B4BE6F8ACAA836032CFF39A
D2EEC675F7D2A131208962BFEFA0A8B70D263925BF93DA09B3E19F1A2F689507
059F94CAE6303C42A5F408A1D800E64E066224B3721654553022B69844FDF278
A0785B3878BA3F6030504DF40BA636A4A9551B4F162F962930D3B4A94B1FFA2C
3E06AEA0E7DD5E02F33563AA401B59E1E2F5D4EC643CD517C703EFE3A5A8ABBD
ABA83536C2DBCB7F1BE0EA54D531869F0F4D8CBD3220D635319B729B5B22E5CB
DADD574FD8EF7AE6C5E37F0EF4B3A6A902CBED35E34E86D9B7E5E41E5ECAE987
6A83B2F2BFB7038EA90A232AF9F300BFB6A45F55D73BCBBD517EA66E5AC32119
67CE47395770106F772E510A1C7B77850EE8D80846A0C5FFD29D2396DE233159
574D02970DB71B20ED8515A03D9A8AC23B349BF2473FF772A018DCF0FE520887
CF929E5EE3AC3EB428E6633E892463E7A03A5E9C58EBC01169032024AA60D0DA
B6F6EC859610D9127583A23736E16AF49AE1880B34AE90DE148CB3D0FFD7A975
ED43637071D814CD6507971F79CE251B490F99CC486342556BEF9486635D0CB6
C0EE7D0B7809E38C09FF6162AE1E6EF714E60B09C05E9ECB699CF2CFD30CAEE1
E6DD835269B9C150254FC32327825B41D8058F3A9D9130EE5FBAC2577B61822E
A5B202104B2E16DF6ACA0DFE2C767CF4D3A38A14799EBA09F7E9C2D1C0BB2243
3E91B199BCC80D8AB8B071E15FFEF45D3B385B8552E7DF778389868F70890DD9
8CB51E62E154291EC33F4D4B2F9D885607D4FE7E1761528870452B7D5799FA77
C58E0D4BC6F371108BC29009BD9A99EFC8BE5904BC7D78C421AD666771F971BF
D2B720C47989A3F361AD4519209C80D095F3238CEAA56EBFF09D815ADE4115FA
3D82A772CD7B42F0B663CAD6511FD90D0DF4F2C1D90D9D8FFBF259D58309EA60
2EAE3D7638F5A9ABF90C19CA2BC14E3A8317FD3EB618A9020C6648CE231FC868
9CF14F2C68D8472676776406D5551209290D7DD22EAA47E5D63CC387666D120E
70C2A0DD72EDDCD7016123F973DBB333D7ECB0D97BC05E7C37298CBA81D3C590
2954B0B090770EBCBA9D40225FCB4D731ED0D79F95E741F17637E0CA7307E54E
733F4DAA4BCEB227A594C0329B3AFB6FAEFE3D6A7465BA9EE9E05FBBF43C5971
31D41B7DA79725A493B0B399BEB8EAC3B047E221B02F30065DED7D1F79F50EB4
F57EC15C4FE5FC35A10DF058022AF0D136470C8EA665C83EF642526FC9696FD0
6E394F348B2FAF45D4502EE97DB92E4513A98E99306D7E139C4306E5B2C2042C
9422C6FAAAA1B2EE640AF4AF9D36F03B688D1D939EFDD608A21EAE7426622CE9
D257BAF3278CC172641742EAC3BFA609566FD9E70C81062D0DA4B9207073CBD4
DA331E43069D8965E2C77524BF78163F00177417D3FF31900BA89B86DCAF8707
BD8C66EE8222FA45087A574AEB0274401BC247210A29B7E9A0011FE3CF20EB00
38F84951637D05285D657C40762E79DECD8013ED0C55E23AB55E706F1E2BD5A5
51D9C18DA13650F9E14F3D9A661FD6BE4325B99006943800C15B6723E716EFBA
8EFD735620E9B5CBEE1F26F227BB824ED79648D02A4272383C4B29EC8429A6A4
22CF905D02C0902B1626A17BD0836D23C17095D5B0DC862A6E40960A0D49948A
522027BB41959076B3DF333E5AB6C3F698DCFC26A20D5F876184A73AADEEFF56
5B5B3AD5F8274F7FBEDD85E00C52A61056D79D33615816FAC4AC556F23A84832
B5D2A177BE8A980C53F82FA2D51EDF3DD9F6DA7CE219CBD65454EC81A4105B16
EB254E797397940866056630B1681109D0D9A12AB25424C16EAB81BD456CBFE7
E6F37B2B715754BE56EB6D888F71D6FF711AB8B715C424CFDA5B4BE2F43255FD
A808ED6BA9ECB950F1283B8781332D2594529122870DAD8AC59B415B9B676F6D
290E9AE6101833CD2C9DE1EB7897225BBE1A80CF40890674C5A8E7666322A1AA
97D0CF5D8B00D58856A9B7DA75AEF1B7483887982D50FD7E27D464EDAF87652D
79678645D573F73C815FCF1D07E9E36C888B1EE7CE3F938DF4B160DA181E93C8
06F0A80FF795EFBB881D8BFE4B46208FA346ECE1598BB58D66E213DA0D204329
86E7D8575063EECA07D2D451609589E17999B35160AB735F14500EE99A9C3527
32BD0E528D48A25555D6AADC1B439F3A25D967B9C3B13C9654365EC29965643F
0ED0D8AA2B2645F5DD03E91B0970093118909792A4A9F8796851121BA2259B0E
E386447080AD63A4708189D4825AB4B9C39CC94185923070D8C3079122FC537C
1C048DC92FE459C3868B934452E0E5E37C569E431EB6BEF6FCD846BD77B93A3B
7901B021BBBCBAE924BFEF0B066B7C1C553D9BFC48C2241F144EAE8F3B3533AC
20FAB27CB1A1F7B701AC3C3C0F1A44C95841C1839A306DDB36A3437786311A87
129DA1DFC4A206AD86DD6F8EA82E50B4CD697A6E3CD35455A5F54D6EB3E73FC9
B58ADBCEFF1269514C2DF0E031169CCBEABA88B0F112A5546B7DAA042D742542
35A6115CE57ADD623407D5E04CE5A2AA3A512C6EB81DB356B70854D0B95E1FAC
FDC1223F47EA1BB601B0C74C017B607FC40E55DC84158EFC3D968A36A8798593
BEF42A2C1DD905016CD12B94D16D810B8AB870F6033F34461E763B7B8F7FAC7C
14F4D7B8DED091050831A46550AD4355C84F34ACCD553EBC6797B0B4E9DC9C5D
B738C4556361C5F17014822154F17C1B05154E0C8AB25A7529CEFCE699988D35
DBA6428DCFB9ABE0ED86336AFE693B2C99A148D6D91EC3A07B22DD6C741CBBA6
FB89ED1543263433AD42BE0756AF9956D04E83066F5365BF41C630446961CC33
A2897B7578AD75D0843F51983CB96432EA606D0B794977B059C5E62DE36CD836
A350F7894A34AD0D6F60FF4127087C1F9CAF5CCFB115679101CC0755BAA00665
ED48F3F87A25E3FE2B10F96A071E868A6FA991E2437195F9166C98F8DE978D70
00398EA7C7083FF4E437A77A41B5E48CA4123CAAD3E119F64320C7FDAFF3271F
32DA0C2958AA0FB3D675F6D131093482C0D5BB19B3F22F00926A030ED787D34D
13C321DFF079D93BE62F7632D6F8D45F734A7768E596649C969A4C46888C3F50
3B2C6A193B70ED942C0737C0E140676D01B74313A410CBD75CF7A47D83FD5B39
44F4CAED6823DDBAE7C7A4D053E591BCCC5E7BB247AD9879F4D2557057BE0788
4F39FFE68F5939BA2F37DA2E28072C9BBC47D751DD82D053BA66F365CA29CF2A
0C44FA936F4F0C6A74CE0A9739706C29DFD6FF3E051D765B0834C30B5458CF76
C9783856549622651D6BEB6AD19054F8F4273DCDE3250BED49719EB0B8EB4066
E328727890522D0B613B2522BAA08B7D60B318A1BB324C3A601373F76614B155
C6B9F51728E1F20DF6337FB971C794E9B5A31D7C88436372F49D3B44AFF5B7F8
9C8512D8D12631EC77CCAAEA3570F865013A42A2863F352E7FE900C8A6EC1C4A
3D0AD4BEBF4F84A4210B4D65C30072FC0235876601FD3728A18095A0654881D2
C7231F94B99989D89216FACAA515691274AB22C89BE89D426B2E6768FC43B633
C75AC86A19691A1312EA219795FA1EFE04204A5F36FA1DB0ABD380BE5BBA908B
BB6F967CC3872ECCABDB7E153D39632D18F24EED0525FDCE1274FCFFF75B3A46
1B174DFB5C8632757605DA8A4CCAAC339C789E93904E15DCD4492DB68F77CAD7
D16C54FC36D16A6047B664F77F7505E36B21ED9F434BCEFFEE1A6BDEAD408135
FC2ADF68C82232D2F1C103D7FACE027FC74BB868A41E7FBF2A83939120393B14
9C2A18284A91BBA813D896E9F32298DA49274147179CE7C5024806ED830F840E
C1E688715B3A6024A6B2545E4CEC0C72DC2E79E5C78E907B308C2E6D549DB2B1
804777C8914A96282F1B9B5D69F268DD0E85EBDAF04989D90F05BB263E32AA6D
5C81D6452F7666768D0774998FEF028D375206DF2876748753765BDC68A09777
CEE6C20647E15001DB91C1D992325C00BB42012706D9BCDBA4A3BD60CEC82932
1371A3382180C1525B8218578E920D8F540811EDC9AB7A3317BE39474C43EA17
15301672C90CFC75FBE3C5F9999EC05788B4722964F115B8ACA2C09A7B63588C
D5BDB04E43AC01299FAC1B4C1E178ABE8C991FE247D69C257F38CE5291566005
DC08700F97CF462092154F9030D111161D7737623EC43063C462B7D06DFFD893
52162A9B1BA8FDBEB387AA830DE410776E4BC04F38153AFE6EC64820DCE4BA35
4777971B1F1382F1D99A392EF7A31DA5C158F3BEEB8A5497DB96B6921EE3EDE0
7BFA33890085739F109831BDC18EDD11BD250FA1D3334C246D0772D0B24F8248
3F50D06B86CD4D1C83D975514327AE77E25C87DCE0D4A5C1C505D84A325C77B6
235FF31CECD4B2E7572DA8C83049D212AC06D5AB73201F57AA32CC1508B023E2
77EE8E037D2DD16EE63E83F4466756E5288F47A565E03C56C9CF501DCD2C6358
F04854B9F836902781E24A5F4757C92499CDCF429C368AC8D85287360B5AE0DA
CE0F7632EC1F73B5108707D77783BAB6E4A4B9AE8F167DE49E8B061C01B4E9FC
AFF04A4A8476CDA394429482E996991C4B00E5B35CDC0E6714DBE1760DFF0BC9
0000A12F805FA6EECF11D3AB92F5785CAC60480DCD7D8BDBED94C772DF0972A9
FCF33C808FA6BF4370B71A84878F42FE046530C481BC18551DFB641A29C22182
5ECD7903267C655E1310F00ECDCE61DE282EE84C272EB2B0FEE021E9F42AE196
003085B6CCBF8F8FD09A837CECF7613083203B589DA30C7299F6B4306871A8B3
48ADDB56302B3B87BD2C384EFF62CFAA743D8A55FB747EA94A84E70B551C3ED5
5DB67F5A3A2992BE4F72B87A5AF098D5922AECCEEA2420D5F6EA8962BCF17FD2
04BA9AE5957464EED00613184253D71BE52DDEC54E0FAA1D14E8E272C0A2F08E
895A9EEF417E5AFE16CA19A01E79E373309235A3080CFC901050595C155F1E08
B60408C90F1F718E0369EE5A7332D979E61A5CB288DF76C19005A95D590F76DE
A6740083BE831F226F7EFAEB00E6F5AF38B9F79A9D86157072208C81C0DAF874
88EF8AAD3DAD514E9140B4F78858E7CE04D3DE57129EF524FF3A7DE43A4CACD6
584939F331370A464973FF1918BFEE9C30155307130C07EFEFEBC5B699F34BAF
8ECD635B8E6E9101B4DF5454F00FFB9241719DBFE344E5014771AA5337571A87
78486EFC339E2F9A93A56AF09D9AD8FD31AEFCED421E6909833E00EE149905A4
A73E7A862753D245412EBEDF03E1B446FC5F3890A8D01C24B888921CF653E3AF
24E7BFD72D06432B12F5D9516299D00D826413FFE6513AC91C906C17A2AF3BDE
72CC9757A6044F76898194AF1279518D00B8A691F9C0D42505BCBD738A036D6C
EDB9C1283823B756E1B847615CF946AA988C665983046D930FC6E7A4C5EF32DA
D0242DFD47047284486FBBB650ED87522C08206A899069A3B894E6A637501AA6
45D2DD6B27F02AC20D4BBE52DA6175A8ED806C4C40B68A94AC6A23BFCC7628AB
BB27CFE6842C4A441C38FBA01AE7E16EB88CC55044F08DA8151439F1F8B8A486
485BE26A44CEC38D1983932473B56237883EFF6644DE042145332FD6A1C775A6
D9B7084CA58758CEB54FBF76D025BC47E0A5B90C51D70A28F18AA3065F8C797C
6D53B6A9A67BF96F2CC7020D34315797366C1256569CEDEC151C00C9F5022A4F
C500519E9799500EE90C8846B3425E2878C8C4
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258431 52099146 1000 600 600 (main.dvi)
@start /Fa 134[44 44 60 44 46 32 33 33 44 46 42 46 69
23 44 25 23 46 42 25 37 46 37 46 42 9[85 62 1[60 46 4[62
76 2[43 30 62 1[54 1[63 60 59 62 6[23 42 42 42 1[42 42
42 42 42 42 42 23 28 23 2[32 32 23 26[46 12[{}57 83.022
/CMR10 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: Letter
letter
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 0 a
SDict begin [ /Producer (dvips + Distiller) /Title (CS 311 Project 2: UNIX File I/O) /Subject (CS 311 Project 2) /Creator (LaTeX with hyperref package) /Author (Savannah Van Beek) /Keywords (cs311 ``operating systems'' files filesystem I/O) /DOCINFO pdfmark end
 0 0 a 0 TeXcolorgray
0 TeXcolorgray -150 -208 a
SDict begin H.S end
 -150 -208 a 0 TeXcolorgray
0 TeXcolorgray -150 -208 a
SDict begin H.R end
 -150 -208 a -150 -208 a
SDict begin [ /View [/XYZ H.V] /Dest (page.1) cvn H.B /DEST pdfmark end
 -150
-208 a 0 TeXcolorgray Black 0 TeXcolorgray -150 0 a
SDict begin [ /Page 1 /View [ /Fit ] /PageMode /UseNone /DOCVIEW pdfmark end
 -150
0 a -150 0 a
SDict begin [ {Catalog} << >> /PUT pdfmark end
 -150 0 a -150 0 a
SDict begin H.S end
 -150 0 a -150 0 a
SDict begin 12 H.A end
 -150
0 a -150 0 a
SDict begin [ /View [/XYZ H.V] /Dest (Doc-Start) cvn H.B /DEST pdfmark end
 -150 0 a -67 83 a Fa(Sa)n(v)-5 b(annah)27
b(V)-7 b(an)27 b(Beek)-150 183 y(CS)h(311)-150 282 y(02-08-2012)p
0 TeXcolorgray -150 2280 a @beginspecial 50 @llx 50 @lly
410 @urx 302 @ury 4320 @rwi 2160 @rhi @setspecial
%%BeginDocument: things.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Title: things.eps
%%Creator: gnuplot 4.2 patchlevel 6 
%%CreationDate: Wed Feb  8 21:41:44 2012
%%DocumentFonts: (atend)
%%BoundingBox: 50 50 410 302
%%EndComments
%%BeginProlog
/gnudict 256 dict def
gnudict begin
%
% The following 6 true/false flags may be edited by hand if required
% The unit line width may also be changed
%
/Color true def
/Blacktext false def
/Solid false def
/Dashlength 1 def
/Landscape false def
/Level1 false def
/Rounded false def
/TransparentPatterns false def
/gnulinewidth 75.000 def
/userlinewidth gnulinewidth def
%
/vshift -66 def
/dl1 {
  10.0 Dashlength mul mul
  Rounded { currentlinewidth 0.75 mul sub dup 0 le { pop 0.01 } if } if
} def
/dl2 {
  10.0 Dashlength mul mul
  Rounded { currentlinewidth 0.75 mul add } if
} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
Level1 {} {
/SDict 10 dict def
systemdict /pdfmark known not {
  userdict /pdfmark systemdict /cleartomark get put
} if
SDict begin [
  /Title (things.eps)
  /Subject (gnuplot plot)
  /Creator (gnuplot 4.2 patchlevel 6 )
  /Author (Savannah VanBeek)
%  /Producer (gnuplot)
%  /Keywords ()
  /CreationDate (Wed Feb  8 21:41:44 2012)
  /DOCINFO pdfmark
end
} ifelse
%
% Gnuplot Prolog Version 4.2 (August 2006)
%
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/Z {closepath} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow {currentpoint stroke M 0 vshift R 
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/Rshow {currentpoint stroke M dup stringwidth pop neg vshift R
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/Cshow {currentpoint stroke M dup stringwidth pop -2 div vshift R 
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/UP {dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def} def
/DL {Color {setrgbcolor Solid {pop []} if 0 setdash}
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse} def
/BL {stroke userlinewidth 2 mul setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/AL {stroke userlinewidth 2 div setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/UL {dup gnulinewidth mul /userlinewidth exch def
	dup 1 lt {pop 1} if 10 mul /udl exch def} def
/PL {stroke userlinewidth setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
% Default Line colors
/LCw {1 1 1} def
/LCb {0 0 0} def
/LCa {0 0 0} def
/LC0 {1 0 0} def
/LC1 {0 1 0} def
/LC2 {0 0 1} def
/LC3 {1 0 1} def
/LC4 {0 1 1} def
/LC5 {1 1 0} def
/LC6 {0 0 0} def
/LC7 {1 0.3 0} def
/LC8 {0.5 0.5 0.5} def
% Default Line Types
/LTw {PL [] 1 setgray} def
/LTb {BL [] LCb DL} def
/LTa {AL [1 udl mul 2 udl mul] 0 setdash LCa setrgbcolor} def
/LT0 {PL [] LC0 DL} def
/LT1 {PL [4 dl1 2 dl2] LC1 DL} def
/LT2 {PL [2 dl1 3 dl2] LC2 DL} def
/LT3 {PL [1 dl1 1.5 dl2] LC3 DL} def
/LT4 {PL [6 dl1 2 dl2 1 dl1 2 dl2] LC4 DL} def
/LT5 {PL [3 dl1 3 dl2 1 dl1 3 dl2] LC5 DL} def
/LT6 {PL [2 dl1 2 dl2 2 dl1 6 dl2] LC6 DL} def
/LT7 {PL [1 dl1 2 dl2 6 dl1 2 dl2 1 dl1 2 dl2] LC7 DL} def
/LT8 {PL [2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 4 dl2] LC8 DL} def
/Pnt {stroke [] 0 setdash gsave 1 setlinecap M 0 0 V stroke grestore} def
/Dia {stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt} def
/Pls {stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
 } def
/Box {stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt} def
/Crs {stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke} def
/TriU {stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt} def
/Star {2 copy Pls Crs} def
/BoxF {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath fill} def
/TriUF {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill} def
/TriD {stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt} def
/TriDF {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill} def
/Pent {stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt} def
/PentF {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore} def
/Circle {stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt} def
/CircleF {stroke [] 0 setdash hpt 0 360 arc fill} def
/C0 {BL [] 0 setdash 2 copy moveto vpt 90 450 arc} bind def
/C1 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C2 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C3 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C4 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C5 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc
	2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc} bind def
/C6 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C7 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C8 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C9 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 450 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C10 {BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
	2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C11 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C12 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C13 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C14 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 360 arc closepath fill
	vpt 0 360 arc} bind def
/C15 {BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/Rec {newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
	neg 0 rlineto closepath} bind def
/Square {dup Rec} bind def
/Bsquare {vpt sub exch vpt sub exch vpt2 Square} bind def
/S0 {BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare} bind def
/S1 {BL [] 0 setdash 2 copy vpt Square fill Bsquare} bind def
/S2 {BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S3 {BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare} bind def
/S4 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S5 {BL [] 0 setdash 2 copy 2 copy vpt Square fill
	exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S6 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S7 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S8 {BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare} bind def
/S9 {BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S10 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
	Bsquare} bind def
/S11 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
	Bsquare} bind def
/S12 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare} bind def
/S13 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S14 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S15 {BL [] 0 setdash 2 copy Bsquare fill Bsquare} bind def
/D0 {gsave translate 45 rotate 0 0 S0 stroke grestore} bind def
/D1 {gsave translate 45 rotate 0 0 S1 stroke grestore} bind def
/D2 {gsave translate 45 rotate 0 0 S2 stroke grestore} bind def
/D3 {gsave translate 45 rotate 0 0 S3 stroke grestore} bind def
/D4 {gsave translate 45 rotate 0 0 S4 stroke grestore} bind def
/D5 {gsave translate 45 rotate 0 0 S5 stroke grestore} bind def
/D6 {gsave translate 45 rotate 0 0 S6 stroke grestore} bind def
/D7 {gsave translate 45 rotate 0 0 S7 stroke grestore} bind def
/D8 {gsave translate 45 rotate 0 0 S8 stroke grestore} bind def
/D9 {gsave translate 45 rotate 0 0 S9 stroke grestore} bind def
/D10 {gsave translate 45 rotate 0 0 S10 stroke grestore} bind def
/D11 {gsave translate 45 rotate 0 0 S11 stroke grestore} bind def
/D12 {gsave translate 45 rotate 0 0 S12 stroke grestore} bind def
/D13 {gsave translate 45 rotate 0 0 S13 stroke grestore} bind def
/D14 {gsave translate 45 rotate 0 0 S14 stroke grestore} bind def
/D15 {gsave translate 45 rotate 0 0 S15 stroke grestore} bind def
/DiaE {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke} def
/BoxE {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke} def
/TriUE {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke} def
/TriDE {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke} def
/PentE {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore} def
/CircE {stroke [] 0 setdash 
  hpt 0 360 arc stroke} def
/Opaque {gsave closepath 1 setgray fill grestore 0 setgray closepath} def
/DiaW {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke} def
/BoxW {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke} def
/TriUW {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke} def
/TriDW {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke} def
/PentW {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore} def
/CircW {stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke} def
/BoxFill {gsave Rec 1 setgray fill grestore} def
/Density {
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor} def
/BoxColFill {gsave Rec PolyFill} def
/PolyFill {gsave Density fill grestore grestore} def
/h {rlineto rlineto rlineto gsave closepath fill grestore} bind def
%
% PostScript Level 1 Pattern Fill routine for rectangles
% Usage: x y w h s a XX PatternFill
%	x,y = lower left corner of box to be filled
%	w,h = width and height of box
%	  a = angle in degrees between lines and x-axis
%	 XX = 0/1 for no/yes cross-hatch
%
/PatternFill {gsave /PFa [ 9 2 roll ] def
  PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
  PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
  gsave 1 setgray fill grestore clip
  currentlinewidth 0.5 mul setlinewidth
  /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
  0 0 M PFa 5 get rotate PFs -2 div dup translate
  0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 M 0 PFs V} for
  0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 2 1 roll M PFs 0 V} for
 } if
  stroke grestore} def
%
/languagelevel where
 {pop languagelevel} {1} ifelse
 2 lt
	{/InterpretLevel1 true def}
	{/InterpretLevel1 Level1 def}
 ifelse
%
% PostScript level 2 pattern fill definitions
%
/Level2PatternFill {
/Tile8x8 {/PaintType 2 /PatternType 1 /TilingType 1 /BBox [0 0 8 8] /XStep 8 /YStep 8}
	bind def
/KeepColor {currentrgbcolor [/Pattern /DeviceRGB] setcolorspace} bind def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke} 
>> matrix makepattern
/Pat1 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke
	0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke}
>> matrix makepattern
/Pat2 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 0 8 L
	8 8 L 8 0 L 0 0 L fill}
>> matrix makepattern
/Pat3 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 8 M 8 -4 L
	0 12 M 12 0 L stroke}
>> matrix makepattern
/Pat4 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 0 M 8 12 L
	0 -4 M 12 8 L stroke}
>> matrix makepattern
/Pat5 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 8 M 4 -4 L
	0 12 M 8 -4 L 4 12 M 10 0 L stroke}
>> matrix makepattern
/Pat6 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 0 M 4 12 L
	0 -4 M 8 12 L 4 -4 M 10 8 L stroke}
>> matrix makepattern
/Pat7 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 8 -2 M -4 4 L
	12 0 M -4 8 L 12 4 M 0 10 L stroke}
>> matrix makepattern
/Pat8 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 -2 M 12 4 L
	-4 0 M 12 8 L -4 4 M 8 10 L stroke}
>> matrix makepattern
/Pat9 exch def
/Pattern1 {PatternBgnd KeepColor Pat1 setpattern} bind def
/Pattern2 {PatternBgnd KeepColor Pat2 setpattern} bind def
/Pattern3 {PatternBgnd KeepColor Pat3 setpattern} bind def
/Pattern4 {PatternBgnd KeepColor Landscape {Pat5} {Pat4} ifelse setpattern} bind def
/Pattern5 {PatternBgnd KeepColor Landscape {Pat4} {Pat5} ifelse setpattern} bind def
/Pattern6 {PatternBgnd KeepColor Landscape {Pat9} {Pat6} ifelse setpattern} bind def
/Pattern7 {PatternBgnd KeepColor Landscape {Pat8} {Pat7} ifelse setpattern} bind def
} def
%
%
%End of PostScript Level 2 code
%
/PatternBgnd {
  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse
} def
%
% Substitute for Level 2 pattern fill codes with
% grayscale if Level 2 support is not selected.
%
/Level1PatternFill {
/Pattern1 {0.250 Density} bind def
/Pattern2 {0.500 Density} bind def
/Pattern3 {0.750 Density} bind def
/Pattern4 {0.125 Density} bind def
/Pattern5 {0.375 Density} bind def
/Pattern6 {0.625 Density} bind def
/Pattern7 {0.875 Density} bind def
} def
%
% Now test for support of Level 2 code
%
Level1 {Level1PatternFill} {Level2PatternFill} ifelse
%
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
%%EndProlog
gnudict begin
gsave
50 50 translate
0.050 0.050 scale
0 setgray
newpath
(Helvetica) findfont 200 scalefont setfont
/Helvetica findfont 200 scalefont setfont
1.000 UL
LTb
1340 640 M
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 0.01) Rshow
1.000 UL
LTb
1340 1057 M
31 0 V
5529 0 R
-31 0 V
1340 1302 M
31 0 V
5529 0 R
-31 0 V
1340 1475 M
31 0 V
5529 0 R
-31 0 V
1340 1609 M
31 0 V
5529 0 R
-31 0 V
1340 1719 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 80 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 64 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 0.1) Rshow
1.000 UL
LTb
1340 2444 M
31 0 V
5529 0 R
-31 0 V
1340 2688 M
31 0 V
5529 0 R
-31 0 V
1340 2862 M
31 0 V
5529 0 R
-31 0 V
1340 2996 M
31 0 V
5529 0 R
-31 0 V
1340 3106 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 80 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 63 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 1) Rshow
1.000 UL
LTb
1340 3831 M
31 0 V
5529 0 R
-31 0 V
1340 4075 M
31 0 V
5529 0 R
-31 0 V
1340 4248 M
31 0 V
5529 0 R
-31 0 V
1340 4383 M
31 0 V
5529 0 R
-31 0 V
1340 4492 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 81 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 63 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 10) Rshow
1.000 UL
LTb
1340 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 10) Cshow
1.000 UL
LTb
1675 640 M
0 31 V
0 4129 R
0 -31 V
2117 640 M
0 31 V
0 4129 R
0 -31 V
2344 640 M
0 31 V
0 4129 R
0 -31 V
2452 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 100) Cshow
1.000 UL
LTb
2787 640 M
0 31 V
0 4129 R
0 -31 V
3229 640 M
0 31 V
0 4129 R
0 -31 V
3456 640 M
0 31 V
0 4129 R
0 -31 V
3564 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 1000) Cshow
1.000 UL
LTb
3899 640 M
0 31 V
0 4129 R
0 -31 V
4341 640 M
0 31 V
0 4129 R
0 -31 V
4568 640 M
0 31 V
0 4129 R
0 -31 V
4676 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 10000) Cshow
1.000 UL
LTb
5011 640 M
0 31 V
0 4129 R
0 -31 V
5453 640 M
0 31 V
0 4129 R
0 -31 V
5680 640 M
0 31 V
0 4129 R
0 -31 V
5788 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 100000) Cshow
1.000 UL
LTb
6123 640 M
0 31 V
0 4129 R
0 -31 V
6565 640 M
0 31 V
0 4129 R
0 -31 V
6792 640 M
0 31 V
0 4129 R
0 -31 V
6900 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 1e+06) Cshow
1.000 UL
LTb
1.000 UL
LTb
1340 4800 N
0 -4160 V
5560 0 V
0 4160 V
-5560 0 V
Z stroke
LCb setrgbcolor
400 2720 M
currentpoint gsave translate 90 rotate 0 0 M
(Time) Cshow
grestore
LTb
LCb setrgbcolor
4120 140 M
(File Size) Cshow
LTb
1.000 UP
1.000 UL
LTb
1.000 UP
1.000 UL
LT0
/Helvetica findfont 200 scalefont setfont
LTb
5997 4637 M
("data_points2") Rshow
LT0
1340 1719 Pls
2452 1719 Pls
3564 1812 Pls
4676 2271 Pls
5788 3389 Pls
6900 4783 Pls
6388 4637 Pls
1.000 UL
LTb
1340 4800 N
0 -4160 V
5560 0 V
0 4160 V
-5560 0 V
Z stroke
1.000 UP
1.000 UL
LTb
stroke
grestore
end
showpage
%%Trailer
%%DocumentFonts: Helvetica

%%EndDocument
 @endspecial 1809 x @beginspecial 50 @llx 50 @lly 410
@urx 302 @ury 4320 @rwi 2160 @rhi @setspecial
%%BeginDocument: stuff.eps
%!PS-Adobe-2.0 EPSF-2.0
%%Title: stuff.eps
%%Creator: gnuplot 4.2 patchlevel 6 
%%CreationDate: Wed Feb  8 21:43:39 2012
%%DocumentFonts: (atend)
%%BoundingBox: 50 50 410 302
%%EndComments
%%BeginProlog
/gnudict 256 dict def
gnudict begin
%
% The following 6 true/false flags may be edited by hand if required
% The unit line width may also be changed
%
/Color true def
/Blacktext false def
/Solid false def
/Dashlength 1 def
/Landscape false def
/Level1 false def
/Rounded false def
/TransparentPatterns false def
/gnulinewidth 75.000 def
/userlinewidth gnulinewidth def
%
/vshift -66 def
/dl1 {
  10.0 Dashlength mul mul
  Rounded { currentlinewidth 0.75 mul sub dup 0 le { pop 0.01 } if } if
} def
/dl2 {
  10.0 Dashlength mul mul
  Rounded { currentlinewidth 0.75 mul add } if
} def
/hpt_ 31.5 def
/vpt_ 31.5 def
/hpt hpt_ def
/vpt vpt_ def
Level1 {} {
/SDict 10 dict def
systemdict /pdfmark known not {
  userdict /pdfmark systemdict /cleartomark get put
} if
SDict begin [
  /Title (stuff.eps)
  /Subject (gnuplot plot)
  /Creator (gnuplot 4.2 patchlevel 6 )
  /Author (Savannah VanBeek)
%  /Producer (gnuplot)
%  /Keywords ()
  /CreationDate (Wed Feb  8 21:43:39 2012)
  /DOCINFO pdfmark
end
} ifelse
%
% Gnuplot Prolog Version 4.2 (August 2006)
%
/M {moveto} bind def
/L {lineto} bind def
/R {rmoveto} bind def
/V {rlineto} bind def
/N {newpath moveto} bind def
/Z {closepath} bind def
/C {setrgbcolor} bind def
/f {rlineto fill} bind def
/vpt2 vpt 2 mul def
/hpt2 hpt 2 mul def
/Lshow {currentpoint stroke M 0 vshift R 
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/Rshow {currentpoint stroke M dup stringwidth pop neg vshift R
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/Cshow {currentpoint stroke M dup stringwidth pop -2 div vshift R 
	Blacktext {gsave 0 setgray show grestore} {show} ifelse} def
/UP {dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def
  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def} def
/DL {Color {setrgbcolor Solid {pop []} if 0 setdash}
 {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse} def
/BL {stroke userlinewidth 2 mul setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/AL {stroke userlinewidth 2 div setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
/UL {dup gnulinewidth mul /userlinewidth exch def
	dup 1 lt {pop 1} if 10 mul /udl exch def} def
/PL {stroke userlinewidth setlinewidth
	Rounded {1 setlinejoin 1 setlinecap} if} def
% Default Line colors
/LCw {1 1 1} def
/LCb {0 0 0} def
/LCa {0 0 0} def
/LC0 {1 0 0} def
/LC1 {0 1 0} def
/LC2 {0 0 1} def
/LC3 {1 0 1} def
/LC4 {0 1 1} def
/LC5 {1 1 0} def
/LC6 {0 0 0} def
/LC7 {1 0.3 0} def
/LC8 {0.5 0.5 0.5} def
% Default Line Types
/LTw {PL [] 1 setgray} def
/LTb {BL [] LCb DL} def
/LTa {AL [1 udl mul 2 udl mul] 0 setdash LCa setrgbcolor} def
/LT0 {PL [] LC0 DL} def
/LT1 {PL [4 dl1 2 dl2] LC1 DL} def
/LT2 {PL [2 dl1 3 dl2] LC2 DL} def
/LT3 {PL [1 dl1 1.5 dl2] LC3 DL} def
/LT4 {PL [6 dl1 2 dl2 1 dl1 2 dl2] LC4 DL} def
/LT5 {PL [3 dl1 3 dl2 1 dl1 3 dl2] LC5 DL} def
/LT6 {PL [2 dl1 2 dl2 2 dl1 6 dl2] LC6 DL} def
/LT7 {PL [1 dl1 2 dl2 6 dl1 2 dl2 1 dl1 2 dl2] LC7 DL} def
/LT8 {PL [2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 2 dl2 2 dl1 4 dl2] LC8 DL} def
/Pnt {stroke [] 0 setdash gsave 1 setlinecap M 0 0 V stroke grestore} def
/Dia {stroke [] 0 setdash 2 copy vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke
  Pnt} def
/Pls {stroke [] 0 setdash vpt sub M 0 vpt2 V
  currentpoint stroke M
  hpt neg vpt neg R hpt2 0 V stroke
 } def
/Box {stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke
  Pnt} def
/Crs {stroke [] 0 setdash exch hpt sub exch vpt add M
  hpt2 vpt2 neg V currentpoint stroke M
  hpt2 neg 0 R hpt2 vpt2 V stroke} def
/TriU {stroke [] 0 setdash 2 copy vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke
  Pnt} def
/Star {2 copy Pls Crs} def
/BoxF {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath fill} def
/TriUF {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath fill} def
/TriD {stroke [] 0 setdash 2 copy vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke
  Pnt} def
/TriDF {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath fill} def
/DiaF {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath fill} def
/Pent {stroke [] 0 setdash 2 copy gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore Pnt} def
/PentF {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath fill grestore} def
/Circle {stroke [] 0 setdash 2 copy
  hpt 0 360 arc stroke Pnt} def
/CircleF {stroke [] 0 setdash hpt 0 360 arc fill} def
/C0 {BL [] 0 setdash 2 copy moveto vpt 90 450 arc} bind def
/C1 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C2 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C3 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C4 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C5 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc
	2 copy moveto
	2 copy vpt 180 270 arc closepath fill
	vpt 0 360 arc} bind def
/C6 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C7 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 270 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C8 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C9 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 270 450 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C10 {BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill
	2 copy moveto
	2 copy vpt 90 180 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C11 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 180 arc closepath fill
	2 copy moveto
	2 copy vpt 270 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C12 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C13 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 0 90 arc closepath fill
	2 copy moveto
	2 copy vpt 180 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/C14 {BL [] 0 setdash 2 copy moveto
	2 copy vpt 90 360 arc closepath fill
	vpt 0 360 arc} bind def
/C15 {BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill
	vpt 0 360 arc closepath} bind def
/Rec {newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto
	neg 0 rlineto closepath} bind def
/Square {dup Rec} bind def
/Bsquare {vpt sub exch vpt sub exch vpt2 Square} bind def
/S0 {BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare} bind def
/S1 {BL [] 0 setdash 2 copy vpt Square fill Bsquare} bind def
/S2 {BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S3 {BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare} bind def
/S4 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S5 {BL [] 0 setdash 2 copy 2 copy vpt Square fill
	exch vpt sub exch vpt sub vpt Square fill Bsquare} bind def
/S6 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S7 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S8 {BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare} bind def
/S9 {BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare} bind def
/S10 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill
	Bsquare} bind def
/S11 {BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill
	Bsquare} bind def
/S12 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare} bind def
/S13 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy vpt Square fill Bsquare} bind def
/S14 {BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill
	2 copy exch vpt sub exch vpt Square fill Bsquare} bind def
/S15 {BL [] 0 setdash 2 copy Bsquare fill Bsquare} bind def
/D0 {gsave translate 45 rotate 0 0 S0 stroke grestore} bind def
/D1 {gsave translate 45 rotate 0 0 S1 stroke grestore} bind def
/D2 {gsave translate 45 rotate 0 0 S2 stroke grestore} bind def
/D3 {gsave translate 45 rotate 0 0 S3 stroke grestore} bind def
/D4 {gsave translate 45 rotate 0 0 S4 stroke grestore} bind def
/D5 {gsave translate 45 rotate 0 0 S5 stroke grestore} bind def
/D6 {gsave translate 45 rotate 0 0 S6 stroke grestore} bind def
/D7 {gsave translate 45 rotate 0 0 S7 stroke grestore} bind def
/D8 {gsave translate 45 rotate 0 0 S8 stroke grestore} bind def
/D9 {gsave translate 45 rotate 0 0 S9 stroke grestore} bind def
/D10 {gsave translate 45 rotate 0 0 S10 stroke grestore} bind def
/D11 {gsave translate 45 rotate 0 0 S11 stroke grestore} bind def
/D12 {gsave translate 45 rotate 0 0 S12 stroke grestore} bind def
/D13 {gsave translate 45 rotate 0 0 S13 stroke grestore} bind def
/D14 {gsave translate 45 rotate 0 0 S14 stroke grestore} bind def
/D15 {gsave translate 45 rotate 0 0 S15 stroke grestore} bind def
/DiaE {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V closepath stroke} def
/BoxE {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V closepath stroke} def
/TriUE {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V closepath stroke} def
/TriDE {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V closepath stroke} def
/PentE {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  closepath stroke grestore} def
/CircE {stroke [] 0 setdash 
  hpt 0 360 arc stroke} def
/Opaque {gsave closepath 1 setgray fill grestore 0 setgray closepath} def
/DiaW {stroke [] 0 setdash vpt add M
  hpt neg vpt neg V hpt vpt neg V
  hpt vpt V hpt neg vpt V Opaque stroke} def
/BoxW {stroke [] 0 setdash exch hpt sub exch vpt add M
  0 vpt2 neg V hpt2 0 V 0 vpt2 V
  hpt2 neg 0 V Opaque stroke} def
/TriUW {stroke [] 0 setdash vpt 1.12 mul add M
  hpt neg vpt -1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt 1.62 mul V Opaque stroke} def
/TriDW {stroke [] 0 setdash vpt 1.12 mul sub M
  hpt neg vpt 1.62 mul V
  hpt 2 mul 0 V
  hpt neg vpt -1.62 mul V Opaque stroke} def
/PentW {stroke [] 0 setdash gsave
  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat
  Opaque stroke grestore} def
/CircW {stroke [] 0 setdash 
  hpt 0 360 arc Opaque stroke} def
/BoxFill {gsave Rec 1 setgray fill grestore} def
/Density {
  /Fillden exch def
  currentrgbcolor
  /ColB exch def /ColG exch def /ColR exch def
  /ColR ColR Fillden mul Fillden sub 1 add def
  /ColG ColG Fillden mul Fillden sub 1 add def
  /ColB ColB Fillden mul Fillden sub 1 add def
  ColR ColG ColB setrgbcolor} def
/BoxColFill {gsave Rec PolyFill} def
/PolyFill {gsave Density fill grestore grestore} def
/h {rlineto rlineto rlineto gsave closepath fill grestore} bind def
%
% PostScript Level 1 Pattern Fill routine for rectangles
% Usage: x y w h s a XX PatternFill
%	x,y = lower left corner of box to be filled
%	w,h = width and height of box
%	  a = angle in degrees between lines and x-axis
%	 XX = 0/1 for no/yes cross-hatch
%
/PatternFill {gsave /PFa [ 9 2 roll ] def
  PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate
  PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec
  gsave 1 setgray fill grestore clip
  currentlinewidth 0.5 mul setlinewidth
  /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def
  0 0 M PFa 5 get rotate PFs -2 div dup translate
  0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 M 0 PFs V} for
  0 PFa 6 get ne {
	0 1 PFs PFa 4 get div 1 add floor cvi
	{PFa 4 get mul 0 2 1 roll M PFs 0 V} for
 } if
  stroke grestore} def
%
/languagelevel where
 {pop languagelevel} {1} ifelse
 2 lt
	{/InterpretLevel1 true def}
	{/InterpretLevel1 Level1 def}
 ifelse
%
% PostScript level 2 pattern fill definitions
%
/Level2PatternFill {
/Tile8x8 {/PaintType 2 /PatternType 1 /TilingType 1 /BBox [0 0 8 8] /XStep 8 /YStep 8}
	bind def
/KeepColor {currentrgbcolor [/Pattern /DeviceRGB] setcolorspace} bind def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke} 
>> matrix makepattern
/Pat1 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 8 8 L 0 8 M 8 0 L stroke
	0 4 M 4 8 L 8 4 L 4 0 L 0 4 L stroke}
>> matrix makepattern
/Pat2 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 0 M 0 8 L
	8 8 L 8 0 L 0 0 L fill}
>> matrix makepattern
/Pat3 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 8 M 8 -4 L
	0 12 M 12 0 L stroke}
>> matrix makepattern
/Pat4 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -4 0 M 8 12 L
	0 -4 M 12 8 L stroke}
>> matrix makepattern
/Pat5 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 8 M 4 -4 L
	0 12 M 8 -4 L 4 12 M 10 0 L stroke}
>> matrix makepattern
/Pat6 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop -2 0 M 4 12 L
	0 -4 M 8 12 L 4 -4 M 10 8 L stroke}
>> matrix makepattern
/Pat7 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 8 -2 M -4 4 L
	12 0 M -4 8 L 12 4 M 0 10 L stroke}
>> matrix makepattern
/Pat8 exch def
<< Tile8x8
 /PaintProc {0.5 setlinewidth pop 0 -2 M 12 4 L
	-4 0 M 12 8 L -4 4 M 8 10 L stroke}
>> matrix makepattern
/Pat9 exch def
/Pattern1 {PatternBgnd KeepColor Pat1 setpattern} bind def
/Pattern2 {PatternBgnd KeepColor Pat2 setpattern} bind def
/Pattern3 {PatternBgnd KeepColor Pat3 setpattern} bind def
/Pattern4 {PatternBgnd KeepColor Landscape {Pat5} {Pat4} ifelse setpattern} bind def
/Pattern5 {PatternBgnd KeepColor Landscape {Pat4} {Pat5} ifelse setpattern} bind def
/Pattern6 {PatternBgnd KeepColor Landscape {Pat9} {Pat6} ifelse setpattern} bind def
/Pattern7 {PatternBgnd KeepColor Landscape {Pat8} {Pat7} ifelse setpattern} bind def
} def
%
%
%End of PostScript Level 2 code
%
/PatternBgnd {
  TransparentPatterns {} {gsave 1 setgray fill grestore} ifelse
} def
%
% Substitute for Level 2 pattern fill codes with
% grayscale if Level 2 support is not selected.
%
/Level1PatternFill {
/Pattern1 {0.250 Density} bind def
/Pattern2 {0.500 Density} bind def
/Pattern3 {0.750 Density} bind def
/Pattern4 {0.125 Density} bind def
/Pattern5 {0.375 Density} bind def
/Pattern6 {0.625 Density} bind def
/Pattern7 {0.875 Density} bind def
} def
%
% Now test for support of Level 2 code
%
Level1 {Level1PatternFill} {Level2PatternFill} ifelse
%
/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont
dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall
currentdict end definefont pop
end
%%EndProlog
gnudict begin
gsave
50 50 translate
0.050 0.050 scale
0 setgray
newpath
(helvetica) findfont 200 scalefont setfont
/helvetica findfont 200 scalefont setfont
1.000 UL
LTb
1340 640 M
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 0.01) Rshow
1.000 UL
LTb
1340 1057 M
31 0 V
5529 0 R
-31 0 V
1340 1302 M
31 0 V
5529 0 R
-31 0 V
1340 1475 M
31 0 V
5529 0 R
-31 0 V
1340 1609 M
31 0 V
5529 0 R
-31 0 V
1340 1719 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 80 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 64 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 0.1) Rshow
1.000 UL
LTb
1340 2444 M
31 0 V
5529 0 R
-31 0 V
1340 2688 M
31 0 V
5529 0 R
-31 0 V
1340 2862 M
31 0 V
5529 0 R
-31 0 V
1340 2996 M
31 0 V
5529 0 R
-31 0 V
1340 3106 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 80 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 63 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 1) Rshow
1.000 UL
LTb
1340 3831 M
31 0 V
5529 0 R
-31 0 V
1340 4075 M
31 0 V
5529 0 R
-31 0 V
1340 4248 M
31 0 V
5529 0 R
-31 0 V
1340 4383 M
31 0 V
5529 0 R
-31 0 V
1340 4492 M
31 0 V
5529 0 R
-31 0 V
-5529 93 R
31 0 V
5529 0 R
-31 0 V
-5529 81 R
31 0 V
5529 0 R
-31 0 V
-5529 71 R
31 0 V
5529 0 R
-31 0 V
-5529 63 R
63 0 V
5497 0 R
-63 0 V
-5617 0 R
( 10) Rshow
1.000 UL
LTb
1340 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 10) Cshow
1.000 UL
LTb
1675 640 M
0 31 V
0 4129 R
0 -31 V
2117 640 M
0 31 V
0 4129 R
0 -31 V
2344 640 M
0 31 V
0 4129 R
0 -31 V
2452 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 100) Cshow
1.000 UL
LTb
2787 640 M
0 31 V
0 4129 R
0 -31 V
3229 640 M
0 31 V
0 4129 R
0 -31 V
3456 640 M
0 31 V
0 4129 R
0 -31 V
3564 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 1000) Cshow
1.000 UL
LTb
3899 640 M
0 31 V
0 4129 R
0 -31 V
4341 640 M
0 31 V
0 4129 R
0 -31 V
4568 640 M
0 31 V
0 4129 R
0 -31 V
4676 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 10000) Cshow
1.000 UL
LTb
5011 640 M
0 31 V
0 4129 R
0 -31 V
5453 640 M
0 31 V
0 4129 R
0 -31 V
5680 640 M
0 31 V
0 4129 R
0 -31 V
5788 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 100000) Cshow
1.000 UL
LTb
6123 640 M
0 31 V
0 4129 R
0 -31 V
6565 640 M
0 31 V
0 4129 R
0 -31 V
6792 640 M
0 31 V
0 4129 R
0 -31 V
6900 640 M
0 63 V
0 4097 R
0 -63 V
0 -4297 R
( 1e+06) Cshow
1.000 UL
LTb
1.000 UL
LTb
1340 4800 N
0 -4160 V
5560 0 V
0 4160 V
-5560 0 V
Z stroke
LCb setrgbcolor
400 2720 M
currentpoint gsave translate 90 rotate 0 0 M
(Time) Cshow
grestore
LTb
LCb setrgbcolor
4120 140 M
(File Size) Cshow
LTb
1.000 UP
1.000 UL
LTb
1.000 UP
1.000 UL
LT0
/helvetica findfont 200 scalefont setfont
LTb
5997 4637 M
("data_points") Rshow
LT0
1340 1812 Pls
2452 1812 Pls
3564 1812 Pls
4676 2310 Pls
5788 3350 Pls
6900 4745 Pls
6388 4637 Pls
1.000 UL
LTb
1340 4800 N
0 -4160 V
5560 0 V
0 4160 V
-5560 0 V
Z stroke
1.000 UP
1.000 UL
LTb
stroke
grestore
end
showpage
%%Trailer
%%DocumentFonts: helvetica

%%EndDocument
 @endspecial 0 TeXcolorgray -67 4287 a(My)20 b(design)g(decisions)f
(for)h(this)g(assignmen)n(t)f(consisted)h(of)g(not)-150
4386 y(using)31 b(mallo)r(c,)h(hard)f(co)r(ding)h(the)g(n)n(um)n(b)r
(er)f(of)g(c)n(hildren)h(\(for)f(a)-150 4486 y(total)k(of)f(50\),)i
(not)f(reading)f(in)h(input)g(from)g(the)g(user)f(for)g(the)-150
4586 y(n)n(um)n(b)r(er)29 b(of)f(c)n(hildren,)h(left)h(punctuation)f
(in,)g(and)g(I)g(didn't)h(use)-150 4685 y(functions.)61
b(I)35 b(w)n(as)g(originally)f(planning)h(on)g(going)f(bac)n(k)h(and)
-150 4785 y(use)30 b(mallac)f(since)h(I)g(didn't)h(with)f(the)h(last)e
(assignmen)n(t,)h(but)h(I)-150 4885 y(ran)24 b(out)g(of)g(time)h
(trying)f(to)h(just)g(get)f(the)h(program)d(w)n(orking)h(to)-150
4984 y(go)i(bac)n(k)f(and)h(try)h(to)f(implemen)n(t)h(mallo)r(c.)36
b(So)25 b(b)r(ecause)g(of)g(that)-150 5084 y(I)j(just)g(hard)f(co)r
(ded)g(the)h(n)n(um)n(b)r(er)g(of)f(c)n(hildren)g(that)h(the)p
0 TeXcolorgray 0 TeXcolorgray 2075 4259 a(program)k(mak)n(es)h(at)h
(50.)56 b(Then)34 b(when)h(parsing)e(I)h(c)n(hose)f(to)1992
4358 y(lea)n(v)n(e)i(the)i(punctuation)f(in)h(including)g(p)r(erio)r
(ds,)h(comas,)g(and)1992 4458 y(ap)r(ostrophes.)53 b(I)33
b(also)f(c)n(hose)h(not)g(to)h(use)f(functions.)55 b(Not)34
b(for)1992 4557 y(an)n(y)28 b(real)g(reason,)g(I)h(just)h(ended)f(up)h
(putting)f(it)h(all)f(in)g(the)g(one)1992 4657 y(\014le.)37
b(I)27 b(also)g(reciev)n(ed)f(debugging)h(help)h(from)f(Jonah)g(Bro)r
(oks.)p 0 TeXcolorgray 1929 5349 a(1)p 0 TeXcolorgray
eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
0 TeXcolorgray -150 -208 a
SDict begin H.S end
 -150 -208 a 0 TeXcolorgray
0 TeXcolorgray -150 -208 a
SDict begin H.R end
 -150 -208 a -150 -208 a
SDict begin [ /View [/XYZ H.V] /Dest (page.2) cvn H.B /DEST pdfmark end
 -150
-208 a 0 TeXcolorgray 0 TeXcolorgray -67 3 3800 4 v -69
103 4 100 v -17 73 a Fa(Commit)28 b(time)p 1831 103 V
1415 w(Commit)g(Message)p 3731 103 V -67 106 3800 4 v
-69 1003 4 897 v -17 176 a(T)-7 b(ue)28 b(F)-7 b(eb)28
b(7)f(22:49:21)e(2012)g(-0800)p 1831 1003 V 796 w(I)31
b(forgot)f(to)h(commit)g(y)n(esterda)n(y)-7 b(,)30 b(but)i(to)r(da)n(y)
e(and)h(y)n(es-)1882 276 y(terda)n(y)20 b(I)h(w)n(as)f(able)h(to)f
(\014x)h(quite)g(a)g(few)g(bugs)g(\(one)f(b)r(eing)1882
375 y(me)33 b(t)n(yping)f(fdclose)h(instead)f(of)h(just)g(fclose,)g
(that)g(one)1882 475 y(w)n(as)f(fun..\).)53 b(My)33 b(parser)e(is)h
(\014nished,)i(it)f(mak)n(es)f(ev)n(ery)1882 575 y(w)n(ord)26
b(lo)n(w)n(ercase)f(and)i(feeds)g(through)g(the)g(pip)r(es)h(prop-)1882
674 y(erly)-7 b(,)26 b(and)g(it)g(then)h(go)r(es)d(through)i(the)g
(sort)f(to)h(the)g(sup-)1882 774 y(pressor)e(lik)n(e)h(it)h(should.)36
b(Still)27 b(w)n(orking)d(on)h(getting)g(the)1882 873
y(w)n(ords)i(in)h(from)g(the)g(sort)f(and)h(sorting)f(those)g(together)
1882 973 y(in)h(the)g(righ)n(t)f(order.)p 3731 1003 V
-67 1006 3800 4 v -69 1504 4 499 v -17 1076 a(Sun)h(F)-7
b(eb)28 b(5)f(22:58:20)e(2012)h(-0800)p 1831 1504 V 793
w(Finished)34 b(the)f(fdop)r(en,)i(fputs,)g(and)e(fgets.)53
b(I)33 b(\014xed)g(an)1882 1176 y(unfortunate)26 b(fork)f(b)r(om)n(b,)h
(\014xed)g(segmen)n(tation)e(faults,)1882 1275 y(and)k(m)n(y)g(co)r(de)
g(compiles)g(without)g(errors.)36 b(Ho)n(w)n(ev)n(er)26
b(it)1882 1375 y(do)r(esn't)h(app)r(ear)f(to)g(do)h(what)f(it)h(needs)g
(to,)g(but)g(that)g(is)1882 1474 y(for)h(tomorro)n(w.)p
3731 1504 V -67 1508 3800 4 v -69 1807 4 299 v -17 1577
a(F)-7 b(ri)27 b(F)-7 b(eb)28 b(3)g(21:53:14)c(2012)i(-0800)p
1831 1807 V 829 w(F)-7 b(orking)31 b(is)g(done,)i(pip)r(e)f(creation)e
(is)h(done,)i(pip)r(e)f(dele-)1882 1677 y(tion)e(is)f(mostly)g(done)g
(\(still)h(in)g(progress\),)d(and)i(distin-)1882 1777
y(quishmen)n(t)22 b(b)r(et)n(w)n(een)f(paren)n(t/)f(c)n(hild/)h(and)g
(suppressor.)p 3731 1807 V -67 1810 3800 4 v -69 2308
4 499 v -17 1880 a(W)-7 b(ed)28 b(F)-7 b(eb)28 b(1)f(22:57:30)e(2012)h
(-0800)p 1831 2308 V 770 w(W)-7 b(ork)n(ed)29 b(on)h(the)g(basic)f(co)r
(de.)44 b(I)30 b(created)f(a)g(v)n(ery)g(basic)1882 1979
y(parser.)63 b(Started)37 b(making)f(m)n(y)g(pip)r(es)i(and)e(fork)n
(ed.)63 b(I)1882 2079 y(think)25 b(I)g(found)g(a)f(w)n(a)n(y)f(to)h(ID)
h(the)g(c)n(hildren,)g(and)f(closed)1882 2178 y(the)29
b(unneccessary)d(pip)r(es.)37 b(And)29 b(did)f(a)f(lot)h(more)f(read-)
1882 2278 y(ing..)p 3731 2308 V -67 2311 3800 4 v -69
2511 4 200 v -17 2381 a(Mon)g(Jan)g(30)g(17:53:08)e(2012)g(-0800)p
1831 2511 V 727 w(Started)h(the)f(outline)h(of)f(the)h(co)r(de)f(and)g
(did)h(a)f(lot)g(more)1882 2481 y(reading)p 3731 2511
V -67 2514 3800 4 v 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
1929 5349 a(2)p 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
