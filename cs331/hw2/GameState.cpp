#include "GameState.h"
#include <iostream>

GameState::GameState(char p1Arg, char p2Arg) 
{ 
    isP1sTurn = true;
    catsGame = false;
    p1Victory = false;
    p2Victory = false;
    utility = 0;
    optimalNextMove = 0;

    std::srand(std::time(NULL));

    for(int i = 0; i < 9; i++) {
        board[i] = ' '; // Create empty game board
        remainingMoves.insert(i); // Allow all moves from start
    }

    p1 = p1Arg;
    p2 = p2Arg;
    if(p1 != 'h' && p1 != 'm' && p1 != 'r'){
        p1 = 'h';
    }
    if(p2 != 'h' && p2 != 'm' && p2 != 'r'){
        p2 = 'h';
    }
}

        
GameState *GameState::successor(GameState *parent, int move)
{
    GameState *child = new GameState(p1,p2);

    child->isP1sTurn = parent->isP1sTurn;
    for (int i = 0; i < 9; i++) {
        child->board[i] = parent->board[i];
    }
    child->remainingMoves = parent->remainingMoves;

    child->makeMove(move);

    return child;
}

void GameState::updateUtility()
{
    GameState *newState;
    
    int minUtility = 200;
    int minUtilityMove = 0;

    int maxUtility = -200;
    int maxUtilityMove = 0;

    successors.clear(); // Recalculating all of them anyway, so purge this

    if (gameOver()) {
        if (catsGame) {
            utility = 0;
        }
        else {
            utility = (p1Victory) ? 100 : -100;            
        }
    }
    else {
        for (std::set<int>::const_iterator moveIterator = remainingMoves.begin();
                moveIterator != remainingMoves.end();
                moveIterator++){
            // Add the successor generated by this move to the set of successors
            newState = successor(this,(*moveIterator));
            successors.insert(newState);

            newState->updateUtility();
            if (newState->utility < minUtility) {
                minUtility = newState->utility;
                minUtilityMove = (*moveIterator);
            }
            if (newState->utility > maxUtility) {
                maxUtility = newState->utility;
                maxUtilityMove = (*moveIterator);
            }

        }
        utility = (isP1sTurn) ? (maxUtility) : (minUtility);
        optimalNextMove = (isP1sTurn) ? (maxUtilityMove) : (minUtilityMove);
    }
}


bool GameState::isValidMove(int move) 
{
    bool isValid = false;
    if (remainingMoves.count(move) != 0) {
        isValid = true;
    }
    return isValid;
}

bool GameState::gameOver() 
{
    return catsGame || p1Victory || p2Victory;
}

// TODO: getWinner() function for finding out who won?

void GameState::makeMove(int move) 
{
    char token = (isP1sTurn) ? 'X' : 'O';
    board[move] = token;
    remainingMoves.erase(move);
    
    // Check win/loss conditions
    if ((board[0] == token && board[1] == token && board[2] == token) ||
        (board[3] == token && board[4] == token && board[5] == token) ||
        (board[6] == token && board[7] == token && board[8] == token) ||
        (board[0] == token && board[3] == token && board[6] == token) ||
        (board[1] == token && board[4] == token && board[7] == token) ||
        (board[2] == token && board[5] == token && board[8] == token) ||
        (board[0] == token && board[4] == token && board[8] == token) ||
        (board[2] == token && board[4] == token && board[6] == token)) 
    {
        if (isP1sTurn) {
            p1Victory = true;
        }
        else {
            p2Victory = true;
        }   
    }
    else if (remainingMoves.size() == 0) {
        catsGame = true;
    }
    

    isP1sTurn = !isP1sTurn; // Toggle whose turn it is
}

void GameState::nextMove() 
{
    char mode = (isP1sTurn) ? p1 : p2;
    int selectedMove = 0;

    // Note: all these functions should do error checking
    if (mode == HUMAN_PLAYER) {
        selectedMove = humanMove();
    }
    else if (mode == MINIMAX_PLAYER) {
        selectedMove = minimaxMove();
    }
    else {
        selectedMove = randomMove();
    }
    
    makeMove(selectedMove);
}

void GameState::updateScreen()
{
    // TODO: Change this to use a GUI
    std::cout << "Current game board:";
    std::cout << "\n" << 
        board[6] << " | " << board[7] << " | " << board[8] << "\n" <<
        board[3] << " | " << board[4] << " | " << board[5] << "\n" <<
        board[0] << " | " << board[1] << " | " << board[2] << "\n";
        
    std::cout << "\n";

}



int GameState::humanMove()
{
    int selectedMove = 0;
    std::cout << "Please select an available move using your keypad: ";
    std::cin >> selectedMove;
    selectedMove = selectedMove - 1; // Offset for numpad layout
    
    if (isValidMove(selectedMove) == false) {
        std::cout << "Not a valid move, please select again: ";
        std::cin >> selectedMove;
        selectedMove = selectedMove - 1;
    }

    return selectedMove;

}

int GameState::randomMove()
{
    int move = 0;
    int movesLeft = remainingMoves.size();
    int randomIndex = rand() % movesLeft;

    std::set<int>::const_iterator moveIterator = remainingMoves.begin();

    // Move to the iterator representing a random valid move
    for(int i = 0; i < randomIndex; i++) {
        moveIterator++;
    }
    
    move = (*moveIterator);

    return move;
}

int GameState::minimaxMove()
{
    int selectedMove = 0;
    updateUtility();
    selectedMove = optimalNextMove;
    return selectedMove;
}
